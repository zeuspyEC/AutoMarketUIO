name: Automated Deployment

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, staging, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false

env:
  KUBECTL_VERSION: '1.27.0'
  HELM_VERSION: '3.12.0'
  ARGOCD_VERSION: '2.7.0'

jobs:
  # Pre-deployment checks
  pre-deploy:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      version: ${{ steps.determine-version.outputs.version }}
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3

    - name: Determine environment
      id: determine-env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        else
          case "${{ github.ref }}" in
            refs/heads/main) echo "environment=production" >> $GITHUB_OUTPUT ;;
            refs/heads/staging) echo "environment=staging" >> $GITHUB_OUTPUT ;;
            refs/heads/develop) echo "environment=development" >> $GITHUB_OUTPUT ;;
            *) echo "environment=development" >> $GITHUB_OUTPUT ;;
          esac
        fi

    - name: Determine version
      id: determine-version
      run: |
        if [ "${{ github.event.inputs.version }}" != "" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=$(git describe --tags --always)" >> $GITHUB_OUTPUT
        fi

    - name: Validate deployment configuration
      run: |
        echo "Validating deployment for:"
        echo "Environment: ${{ steps.determine-env.outputs.environment }}"
        echo "Version: ${{ steps.determine-version.outputs.version }}"
        
        # Validar que existen los archivos de configuración necesarios
        test -f "k8s/overlays/${{ steps.determine-env.outputs.environment }}/kustomization.yaml"
        test -f "infrastructure/terraform/environments/${{ steps.determine-env.outputs.environment }}/terraform.tfvars"

  # Database migrations
  database-migration:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: pre-deploy
    environment: ${{ needs.pre-deploy.outputs.environment }}
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Install migration tools
      run: |
        cd backend
        npm ci --only=production

    - name: Run migrations
      run: |
        cd backend
        npm run migrate:deploy
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        ENVIRONMENT: ${{ needs.pre-deploy.outputs.environment }}

    - name: Verify migrations
      run: |
        cd backend
        npm run migrate:status

  # Blue-Green Deployment
  blue-green-deploy:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [pre-deploy, database-migration]
    environment: ${{ needs.pre-deploy.outputs.environment }}
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}

    - name: Configure kubeconfig
      run: |
        aws eks update-kubeconfig --name automarket-${{ needs.pre-deploy.outputs.environment }} --region us-east-1

    - name: Deploy Green environment
      run: |
        # Deploy new version to green environment
        helm upgrade --install automarket-green ./charts/automarket \
          --namespace ${{ needs.pre-deploy.outputs.environment }} \
          --values ./charts/automarket/values-${{ needs.pre-deploy.outputs.environment }}.yaml \
          --set image.tag=${{ needs.pre-deploy.outputs.version }} \
          --set blueGreen.productionSlot=green \
          --wait --timeout 10m

    - name: Run smoke tests on Green
      run: |
        GREEN_URL=$(kubectl get service automarket-green -n ${{ needs.pre-deploy.outputs.environment }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        npm run test:smoke -- --url=http://$GREEN_URL

    - name: Switch traffic to Green
      run: |
        kubectl patch service automarket-lb -n ${{ needs.pre-deploy.outputs.environment }} \
          -p '{"spec":{"selector":{"slot":"green"}}}'

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/automarket-green -n ${{ needs.pre-deploy.outputs.environment }}
        
    - name: Tag Blue as previous
      run: |
        kubectl label deployment automarket-blue version=previous --overwrite -n ${{ needs.pre-deploy.outputs.environment }}

  # Canary Deployment (para producción)
  canary-deploy:
    name: Canary Deployment
    runs-on: ubuntu-latest
    needs: [pre-deploy, database-migration]
    if: needs.pre-deploy.outputs.environment == 'production'
    environment: production-canary
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3

    - name: Setup Flagger
      run: |
        kubectl apply -f infrastructure/k8s/flagger/

    - name: Create Canary deployment
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: flagger.app/v1beta1
        kind: Canary
        metadata:
          name: automarket-canary
          namespace: production
        spec:
          targetRef:
            apiVersion: apps/v1
            kind: Deployment
            name: automarket
          service:
            port: 80
          analysis:
            interval: 1m
            threshold: 10
            maxWeight: 50
            stepWeight: 10
            metrics:
            - name: request-success-rate
              thresholdRange:
                min: 99
              interval: 1m
            - name: request-duration
              thresholdRange:
                max: 500
              interval: 1m
          webhooks:
            - name: load-test
              url: http://flagger-loadtester.test/
              metadata:
                cmd: "hey -z 1m -q 10 -c 2 http://automarket-canary.production/"
        EOF

    - name: Monitor canary progress
      run: |
        kubectl -n production wait canary/automarket-canary --for=condition=Promoted --timeout=30m

  # Post-deployment tasks
  post-deploy:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [pre-deploy, blue-green-deploy]
    if: always()
    environment: ${{ needs.pre-deploy.outputs.environment }}
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3

    - name: Clear CDN cache
      run: |
        aws cloudfront create-invalidation \
          --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
          --paths "/*"

    - name: Update monitoring dashboards
      run: |
        # Update Grafana dashboards
        curl -X POST https://grafana.automarket-quito.com/api/dashboards/db \
          -H "Authorization: Bearer ${{ secrets.GRAFANA_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d @monitoring/dashboards/deployment.json

    - name: Run E2E tests
      run: |
        npm run test:e2e -- --env ${{ needs.pre-deploy.outputs.environment }}

    - name: Performance baseline
      run: |
        npm run test:performance -- --env ${{ needs.pre-deploy.outputs.environment }}

    - name: Update status page
      run: |
        curl -X POST https://api.statuspage.io/v1/pages/${{ secrets.STATUSPAGE_ID }}/incidents \
          -H "Authorization: OAuth ${{ secrets.STATUSPAGE_API_KEY }}" \
          -d '{
            "incident": {
              "name": "Deployment completed",
              "status": "resolved",
              "impact": "none",
              "body": "Version ${{ needs.pre-deploy.outputs.version }} deployed successfully"
            }
          }'

  # Rollback mechanism
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [pre-deploy, blue-green-deploy, post-deploy]
    if: failure()
    environment: ${{ needs.pre-deploy.outputs.environment }}-rollback
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --name automarket-${{ needs.pre-deploy.outputs.environment }}

    - name: Initiate rollback
      run: |
        echo "🔄 Initiating rollback for ${{ needs.pre-deploy.outputs.environment }}"
        
        # Switch traffic back to blue
        kubectl patch service automarket-lb -n ${{ needs.pre-deploy.outputs.environment }} \
          -p '{"spec":{"selector":{"slot":"blue"}}}'
        
        # Scale down green deployment
        kubectl scale deployment automarket-green -n ${{ needs.pre-deploy.outputs.environment }} --replicas=0

    - name: Verify rollback
      run: |
        kubectl rollout status deployment/automarket-blue -n ${{ needs.pre-deploy.outputs.environment }}

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            text: "⚠️ Deployment rolled back",
            attachments: [{
              color: 'warning',
              fields: [{
                title: 'Environment',
                value: '${{ needs.pre-deploy.outputs.environment }}',
                short: true
              }, {
                title: 'Version',
                value: '${{ needs.pre-deploy.outputs.version }}',
                short: true
              }]
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # Deployment notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [pre-deploy, blue-green-deploy, post-deploy]
    if: always()
    
    steps:
    - name: Send deployment notification
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            text: "${{ job.status == 'success' && '✅' || '❌' }} Deployment ${{ job.status }}",
            attachments: [{
              color: '${{ job.status == 'success' && 'good' || 'danger' }}',
              fields: [{
                title: 'Environment',
                value: '${{ needs.pre-deploy.outputs.environment }}',
                short: true
              }, {
                title: 'Version',
                value: '${{ needs.pre-deploy.outputs.version }}',
                short: true
              }, {
                title: 'Deployed by',
                value: '${{ github.actor }}',
                short: true
              }, {
                title: 'Commit',
                value: '${{ github.sha }}',
                short: true
              }]
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

    - name: Update deployment tracking
      run: |
        echo "Deployment completed at $(date)" >> deployment-history.log
        echo "Environment: ${{ needs.pre-deploy.outputs.environment }}" >> deployment-history.log
        echo "Version: ${{ needs.pre-deploy.outputs.version }}" >> deployment-history.log
        echo "Status: ${{ job.status }}" >> deployment-history.log
        echo "---" >> deployment-history.log
